#!/usr/bin/env python3
# Copyright (C) 2019-2024 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause
"""
This script is the main executable of Code Base Investigator.
"""

import argparse
import logging
import os
import sys

from codebasin import CodeBase, config, finder, report, util
from codebasin._detail.logging import Formatter, WarningAggregator

log = logging.getLogger("codebasin")
version = "1.2.0"


def _help_string(*lines: str, is_long=False, is_last=False):
    """
    Parameters
    ----------
    *lines: str
        Each line in the help string.

    is_long: bool
        A flag indicating whether the option is long enough to generate an
        initial newline by default.

    is_last: bool
        A flag indicating whether the option is the last in the list.

    Returns
    -------
        An argparse help string formatted as a paragraph.
    """
    result = ""

    # A long option like --exclude will force a newline.
    if not is_long:
        result = "\n"

    # argparse.HelpFormatter indents by 24 characters.
    # We cannot override this directly, but can delete them with backspaces.
    lines = ["\b" * 20 + x for x in lines]

    # The additional space is required for argparse to respect newlines.
    result += "\n".join(lines)

    if not is_last:
        result += "\n "

    return result


def _main():
    # Read command-line arguments
    parser = argparse.ArgumentParser(
        description="Code Base Investigator " + str(version),
        formatter_class=argparse.RawTextHelpFormatter,
        add_help=False,
    )
    parser.add_argument(
        "-h",
        "--help",
        action="help",
        help=_help_string("Display help message and exit."),
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"Code Base Investigator {version}",
        help=_help_string("Display version information and exit."),
    )
    parser.add_argument(
        "-v",
        "--verbose",
        dest="verbose",
        action="count",
        default=0,
        help=_help_string("Increase verbosity level."),
    )
    parser.add_argument(
        "-q",
        "--quiet",
        dest="quiet",
        action="count",
        default=0,
        help=_help_string("Decrease verbosity level."),
    )
    parser.add_argument(
        "-R",
        "--report",
        dest="reports",
        metavar="<report>",
        action="append",
        default=[],
        choices=["all", "summary", "clustering", "duplicates"],
        help=_help_string(
            "Generate a report of the specified type:",
            "- summary: code divergence information",
            "- clustering: distance matrix and dendrogram",
            "- duplicates: detected duplicate files",
            "- files: information about individual files",
            "May be specified multiple times.",
            "If not specified, all reports will be generated.",
            is_long=True,
        ),
    )
    parser.add_argument(
        "-x",
        "--exclude",
        dest="excludes",
        metavar="<pattern>",
        action="append",
        default=[],
        help=_help_string(
            "Exclude files matching this pattern from the code base.",
            "May be specified multiple times.",
            is_long=True,
        ),
    )
    parser.add_argument(
        "-p",
        "--platform",
        dest="platforms",
        metavar="<platform>",
        action="append",
        default=[],
        help=_help_string(
            "Include the specified platform in the analysis.",
            "May be specified multiple times.",
            "If not specified, all platforms will be included.",
            is_long=True,
            is_last=True,
        ),
    )

    parser.add_argument(
        "analysis_file",
        metavar="<analysis-file>",
        help=_help_string(
            "TOML file describing the analysis to be performed, "
            + "including the codebase and platform descriptions.",
            is_last=True,
        ),
    )

    args = parser.parse_args()

    # Configure logging such that:
    # - All messages are written to a log file
    # - Only errors are written to the terminal by default
    # - Messages written to terminal are based on -q and -v flags
    # - Meta-warnings and statistics are generated by a WarningAggregator
    aggregator = WarningAggregator()
    log.setLevel(logging.DEBUG)

    file_handler = logging.FileHandler("cbi.log", mode="w")
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(Formatter())
    file_handler.addFilter(aggregator)
    log.addHandler(file_handler)

    # Inform the user that a log file has been created.
    # 'print' instead of 'log' to ensure the message is visible in the output.
    log_path = os.path.abspath("cbi.log")
    print(f"Log file created at {log_path}")

    log_level = max(1, logging.ERROR - 10 * (args.verbose - args.quiet))
    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setLevel(log_level)
    stdout_handler.setFormatter(Formatter(colors=sys.stdout.isatty()))
    log.addHandler(stdout_handler)

    if "all" in args.reports:
        log.warning("Passing 'all' to -R is deprecated. Omit -R instead.")

    # Determine the root directory based on where codebasin is run.
    rootdir = os.path.abspath(os.getcwd())

    # Set up a default configuration object.
    configuration = {}

    # Load the analysis file if it exists.
    if args.analysis_file is not None:
        path = os.path.abspath(args.analysis_file)
        if os.path.exists(path):
            if not os.path.splitext(path)[1] == ".toml":
                raise RuntimeError(f"Analysis file {path} must end in .toml.")

        with open(path, "rb") as f:
            analysis_toml = util._load_toml(f, "analysis")

        if "codebase" in analysis_toml:
            if "exclude" in analysis_toml["codebase"]:
                args.excludes += analysis_toml["codebase"]["exclude"]

        for name in args.platforms:
            if name not in analysis_toml["platform"].keys():
                raise KeyError(
                    f"Platform {name} requested on the command line "
                    + "does not exist in the configuration file.",
                )

        cmd_platforms = args.platforms.copy()
        for name in analysis_toml["platform"].keys():
            if cmd_platforms and name not in cmd_platforms:
                continue
            if "commands" not in analysis_toml["platform"][name]:
                raise ValueError(f"Missing 'commands' for platform {name}")
            p = analysis_toml["platform"][name]["commands"]
            db = config.load_database(p, rootdir)
            args.platforms.append(name)
            configuration.update({name: db})

    # Construct a codebase object associated with the root directory.
    codebase = CodeBase(rootdir, exclude_patterns=args.excludes)

    # Parse the source tree, and determine source line associations.
    # The trees and associations are housed in state.
    state = finder.find(
        rootdir,
        codebase,
        configuration,
        show_progress=True,
    )

    # Generate meta-warnings and statistics.
    # Temporarily override log_level to ensure they are visible.
    stdout_handler.setLevel(logging.WARNING)
    print("")
    aggregator.warn(log)
    stdout_handler.setLevel(log_level)

    # Count lines for platforms
    setmap = state.get_setmap(codebase)

    def report_enabled(name):
        if "all" in args.reports or len(args.reports) == 0:
            return True
        return name in args.reports

    # Print summary report
    if report_enabled("summary"):
        report.summary(setmap)

    # Print clustering report
    if report_enabled("clustering"):
        basename = os.path.basename(args.analysis_file)
        filename = os.path.splitext(basename)[0]
        output_prefix = "-".join([filename] + args.platforms)

        clustering_output_name = output_prefix + "-dendrogram.png"
        report.clustering(clustering_output_name, setmap)

    # Print duplicates report
    if report_enabled("duplicates"):
        report.duplicates(codebase)

    sys.exit(0)


def main():
    try:
        _main()
    except Exception as e:
        log.error(str(e))
        sys.exit(1)


if __name__ == "__main__":
    sys.argv[0] = "codebasin"
    main()
